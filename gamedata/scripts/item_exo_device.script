-- map of exoskeletons to their power supplies
--[[
    key: id
    value: {
        current power
        supply: {
            name
            drain mult
            max
        }
    }
]]
local exo_devices = {}
-- cached properties of exo devices
local cache = {}
local st = {}
local warn = false
local threshold = 25

local current_outfit

local gc = game.translate_string
local send_tip = news_manager.send_tip

function print_dbg(txt, ...)
	if exo_mcm.get_config("debug") then
		printf("arti_exo | %s | " .. txt, time_global(), ...)
	end
end


function init()
    local ini_exo_device = ini_file("items\\settings\\exo_devices.ltx")
    n = ini_exo_device:line_count("suit_drain")
    for i=0,n-1 do
        local result, sec, value = ini_exo_device:r_line_ex("suit_drain",i,"","")
        cache[sec] = tonumber(value)
    end

    ini_powers:section_for_each(function(section)
        printf("Building sound table for %s", section)
        st[section] = {}
        st[section][1] = sound_object(ini_powers:r_string_ex(section, "snd_windup"))
        st[section][2] = sound_object(ini_powers:r_string_ex(section, "snd_duration"))
        st[section][3] = sound_object(ini_powers:r_string_ex(section, "snd_cooldown"))
    end)
end

-- data management
function get_data(id)
    if exo_devices[id] then
        return dup_table(exo_devices[id])
    end
end

function set_data(id, data)
    -- validate the data first
    if not data then
        print_dbg("No data set for id %s, initializing", id)
        data = {}
        data.power = 0
    end
    if data.supply then
        local name = data.supply.name
        if not cache[name] then
            data.supply = nil
        end
    end
    exo_devices[id] = data
end

function init_data(id)
    local data = {}
    data.power = 0
    set_data(id, data)
    return data
end

-- helpers
-- check if obj is exo outfit
function is_exo(obj)
    local section = obj and obj:section() or false
    if section then
        return SYS_GetParam(0, section, "repair_type") == "outfit_exo"
    end
    return false
end

-- check if actor is wearing exo
function is_wearing_exo() 
    local outfit = db.actor:item_in_slot(7)
    return is_exo(outfit)
end

function exec(str)
    if str then
		str = str_explode(str,"%.") -- dot needs escape character!
		if str[1] and str[2] and _G[ str[1] ] and _G[ str[1] ][ str[2] ] then
			_G[ str[1] ][ str[2] ](obj)
		else
			print_dbg("Could not exec function %s", str)
		end
	end
end

-- right-click options
-- remove supply from exo
function check_remove_psu(obj)
	local p = obj:parent()
	if not (p and p:id() == AC_ID) then return false end
	
    local id = obj:id()
    local data = get_data(id)
    if not data or is_empty(data) then return end
    if not data.supply then return end
    return "st_remove_psu"
end

function remove_psu(obj)
    local id = obj:id()
    local data = get_data(id)
    if not data or is_empty(data) or not data.supply then return end
    if data.power > 100 then data.power = 100 end
    alife_create_item(data.supply.name, db.actor)
    data.supply = nil
    set_data(id, data)
    
end

function install_psu(suit, data, psu)
    if data.supply ~= nil then
        remove_psu(suit)
    end
    local sec_p = psu:section()
    if not cache[sec_p] and SYS_GetParam(2, sec_p, "drain") then
        cache[sec_p] = {
        ["name"] = sec_p,
        ["drain"] =  SYS_GetParam(2, sec_p, "drain") or 1,
        ["max"] = SYS_GetParam(2, sec_p, "capacity") or 100,
        ["ability"] = SYS_GetParam(0, sec_p, "ability")
        }
    end

    if cache[sec_p] then
        data.supply = dup_table(cache[sec_p])
        print_dbg("Installing PSU %s with drain %s, capacity %s", data.supply.name, data.supply.drain, data.supply.max)
        set_data(suit:id(), data)
        update_psu()
        alife_release(psu)
        -- play some sound?
    	xr_sound.set_sound_play(AC_ID,"inv_aam_open")
    end
end

-- Update player base carryweight, and also any other passives
-- function update_psu()
--     local outfit = db.actor:item_in_slot(7)
--     if not outfit or not is_exo(outfit) then exo_powers.update_passives(nil, false) end
    
--     local data = exo_devices[outfit:id()]
    
--     if data and data.supply and data.supply.name then
--         add_weight = SYS_GetParam(2, data.supply.name, "weight_mod") or 0
--         if add_weight > 0 then 
--             weight.add_weight("exo", -add_weight)
--             exo_powers.update_passives(data.supply, true)
--         end
--     else
--         weight.remove_weight("exo_psu")
--     end
-- end

-- charge exo with battery

function menu_battery(obj)
	local p = obj:parent()
	if not (p and p:id() == AC_ID) then
		return false
	end
	local suit = db.actor:item_in_slot(7)
    if not is_exo(suit) then return end
    local id = suit:id()
    local data = get_data(id)
    if not data then data = init_data(id) end
    local max_power = data.supply and data.supply.max or 100
    if data.power < max_power then
        return "st_charge_exo"
    end
    return false
end
function func_battery(obj)
	local p = obj:parent()
	if not (p and p:id() == AC_ID) then
		return
	end
	local suit = db.actor:item_in_slot(7)
    if not is_exo(suit) then return end
    local id = suit:id()
    local data = get_data(id)
    if not data then data = init_data(id) end
    charge_exo(obj, suit, data)
end

-- install psu
function check_install_psu(obj)
	local p = obj:parent()
	if not (p and p:id() == AC_ID) then
		return
	end
    
	local suit = db.actor:item_in_slot(7)
    if not is_exo(suit) then return false end
    local id = suit:id()
    local data = get_data(id)
    if not data then data = init_data(id) end
    return "st_install_psu"
end
function func_install_psu(obj)
	local p = obj:parent()
	if not (p and p:id() == AC_ID) then
		return
	end
	local suit = db.actor:item_in_slot(7)
    if not is_exo(suit) then return end
    local data = get_data(suit:id())
    if not data then data = init_data(suit:id()) end
    install_psu(suit, data, obj)
end

-- use the battery to charge the suit
function charge_exo(battery, suit, data)
    print_dbg("begin charge exo")
    local max_restorable = (data.supply and data.supply.max or 100) - data.power
    local batt_power = math.ceil(battery:condition() * 100)
    local to_restore = math.min(max_restorable, batt_power)
    print_dbg("max_restorable is %s, battery power is %s. restoring %s", max_restorable, batt_power, to_restore)
    if to_restore > 0 then
        data.power = data.power + to_restore
        batt_power = batt_power - to_restore
        if batt_power == 0 then 
            alife_release(battery) 
        else
            battery:set_condition(batt_power/100)
        end
        set_data(suit:id(), data)
        actor_effects.play_item_fx("batteries_dead")
        utils_obj.play_sound("interface\\inv_batt")
    end
end



function actor_on_first_update()
    init()
end
-- drag battery onto suit, or power device onto suit
local function on_item_drag_dropped(obj_d, obj_o, slot_from, slot_to)
	-- Check capability
	if not (slot_from == EDDListType.iActorBag and (slot_to == EDDListType.iActorBag or slot_to == EDDListType.iActorSlot)) then
        return
    end
	
	local sec_d = obj_d:section() -- battery or device
    local sec_o = obj_o:section() -- suit
    print_dbg("dragged %s on %s", sec_d, sec_o)
    if is_exo(obj_o) then
        local id = obj_o:id()
        local data = get_data(id)
        if not data then data = init_data(id) end
        if sec_d == "batteries_exo" then
            -- charge exo
            charge_exo(obj_d, obj_o, data)
        elseif SYS_GetParam(2, sec_d, "drain") then
            -- replace the psu
            install_psu(obj_o, data, obj_d)
        end
    end
end


-- player slowing management
local slow_coef = 0.1
local is_player_slowed = false
local function slow_player()
    if not is_player_slowed then
        print_dbg("slowing player")
        is_player_slowed = true
        speed.add_speed("exo_speed", slow_coef, false, true)
	end
end

local function reset_speed()
    if is_player_slowed then
        print_dbg("restoring speed")
        is_player_slowed = false
        speed.add_speed("exo_speed", 1, false, true)
    end
end

local updated = 0
local interval = 400
function actor_on_update()
    if time_global() < updated then return end
    updated = time_global() + interval
    
    -- update power
    if is_wearing_exo() then
        manage_drain()
    end

    -- update speed
	if (not is_wearing_exo()) then
        reset_speed()
	else
		if exo_charged() then reset_speed() else slow_player() end
	end
end

function exo_charged()
    local exosuit = db.actor:item_in_slot(7)

    if exosuit and is_exo(exosuit) then
        local id = exosuit:id()
        local data = get_data(id)
        if not data then data = init_data(id) end
        return data.power > 0
    end
    return false
end

-- modify drain
local function modify_drain(base_drain, data)
    local drain_mult = exo_mcm.get_config("drain") or 1
    if data.supply then base_drain = base_drain * data.supply.drain end
	if IsMoveState("mcSprint") then
        local fast_mult = exo_mcm.get_config("sprint_drain")
		return base_drain * fast_mult * drain_mult
	elseif IsMoveState("mcAnyMove") then
		return base_drain * drain_mult
	end
    if data.supply and data.supply.ability == "recharge" then return -0.05
    else return 0 end
end

-- patch to modify power in psu
function modify_power(amt)
    
    local exosuit = db.actor:item_in_slot(7)
    if exosuit and is_exo(exosuit) then
        local id = exosuit:id()
        local sec = exosuit:section()
        local data = get_data(id)
        data.power = clamp(data.power + amt, 0, 400)
        set_data(id, data)
    end
end

-- every tick, update the supply power accordingly
function manage_drain()
    local exosuit = db.actor:item_in_slot(7)
    if exosuit and is_exo(exosuit) then
        local id = exosuit:id()
        local sec = exosuit:section()
        local data = get_data(id)
        if not data then data = init_data(id) end
        local base_drain = cache[sec] or 0.01
        base_drain = modify_drain(base_drain, data)
        data.power = clamp(data.power - base_drain, 0, 400)
        set_data(id, data)

        if warn and data.power > threshold then
            warn = false
        end
        -- low power warn
        if not warn and data.power < threshold then
            warn = true
            news_manager.send_tip(db.actor, gc("st_low_power"), nil, "swiss_knife", 6000)
        end
    end
end

-- power management

local start_time
local DURATION = 8000
local COOLDOWN = 20
local power_state = 0
local POWER_READY = 0
local POWER_ACTIVE = 1
local POWER_COOLDOWN = 2

function on_move(obj)
    
    local outfit = db.actor:item_in_slot(7)
    if current_outfit ~= 0 and (not outfit or not is_exo(outfit) or current_outfit ~= outfit:id()) then
        -- kill any running powers
        if power_state == POWER_ACTIVE then
            power_state = POWER_COOLDOWN
        end
        -- kill any passives
        local data = get_data(current_outfit)
        if data and data.supply and data.supply.ability then
            exec(ini_powers:r_string_ex(data.supply.ability, "passive_off"))
        end
        current_outfit = 0
    end

    if outfit and is_exo(outfit) and current_outfit ~= outfit:id() then
        current_outfit = outfit:id()
        -- update passives
        local data = get_data(current_outfit)
        if data and data.supply and data.supply.ability then
            exec(ini_powers:r_string_ex(data.supply.ability, "passive_on"))
        end
    end
end

function activate_powers()
    if not current_outfit or power_state == POWER_ACTIVE then return end
    if power_state == POWER_COOLDOWN then
        -- cooling down
        send_tip(db.actor, gc("st_err_cooldown"), nil, "swiss_knife", 6000)
        return
    end
    local exosuit = db.actor:item_in_slot(7)

    if exosuit and is_exo(exosuit) then
        local id = exosuit:id()
        local sec = exosuit:section()
        local data = get_data(id)

        if not data then
            data = init_data(id)
        end

        print_dbg("equipped power: %s", data.supply and data.supply.ability or "none")

        if not data.supply or not data.supply.ability or not ini_powers:section_exist(data.supply.ability) then
            send_tip(db.actor, gc("st_err_none"), nil, "swiss_knife", 6000)
            return
        end

        local drain = ini_powers:r_float_ex(data.supply.ability, "power_cost") or 20

        if data.power < drain + 10 then
            -- insufficient power
            send_tip(db.actor, gc("st_err_power"), nil, "swiss_knife", 6000)

            return
        end

        data.power = clamp(data.power - drain, 0, 400)
        set_data(id, data)
        power_active = data.supply.ability
        sounds = st[power_active]
        start_time = time_global()
        print_dbg("saved tg %s", start_time)
        local duration = (ini_powers:r_float_ex(data.supply.ability, "power_duration") * 1000) or DURATION 
        local cooldown = ini_powers:r_float_ex(data.supply.ability, "power_cooldown") or COOLDOWN
        local delay =  sounds[1]:length() / 1000
        sounds[1]:play(db.actor, 0, sound_object.s2d)
        CreateTimeEvent("exo_powers", "activate_powers", delay, maintain_power, power_active, duration, cooldown)
    end
end


-- continually run and watch for outfit changes
function maintain_power(power_active, duration, cooldown)
    local id = db.actor:item_in_slot(7) and db.actor:item_in_slot(7):id() or 0
    if not st[power_active][2]:playing() then
        print_dbg("start activate power")
        exec(ini_powers:r_string_ex(power_active, "power_start"))
        st[power_active][2]:play(db.actor, 0, sound_object.s2d)
    end
    if id ~= current_outfit or power_state ~= POWER_ACTIVE or time_global() > start_time + duration then
        deactivate_powers(power_active, cooldown)
        return true
    end

    return false
end

function deactivate_powers(power_active, cooldown)
    exec(ini_powers:r_string_ex(power_active, "power_end"))
    if st[power_active][2]:playing() then 
        st[power_active][2]:stop()
    end
    st[power_active][3]:play(db.actor, 0, sound_object.s2d)
    power_state = POWER_COOLDOWN
    CreateTimeEvent("exo_powers", "deactivate_power", cooldown, function()
        power_state = POWER_READY
        send_tip(db.actor, gc("st_ok_cooldown"), nil, "swiss_knife", 6000)
        return true
    end)
end

CanRepair = inventory_upgrades.can_repair_item
function inventory_upgrades.can_repair_item( sec, cond, mechanic )
    if sec == "batteries_exo" then return false
    else return CanRepair(sec, cond, mechanic) end
end

NameCustom = ui_inventory.UIInventory.Name_Custom
-- hijack functions for exos
function ui_inventory.UIInventory:Name_Custom(obj, bag, temp, i)
	obj = self:CheckItem(obj,"Name_Custom " .. i)
	if i == 3 and is_exo(obj) then
		return check_remove_psu(obj)
	else
		return NameCustom(self, obj, bag, temp, i)
	end
end

ActionCustom = ui_inventory.UIInventory.Action_Custom
function ui_inventory.UIInventory:Action_Custom(obj, bag, temp, i)
	obj = self:CheckItem(obj,"Action_Custom " .. i)
	if i == 3 and is_exo(obj) then -- menu field strip
		remove_psu(obj)
	else
		ActionCustom(self, obj, bag, temp, i)
	end
end

local clr_r  = utils_xml.get_color("d_red")
local clr_g  = utils_xml.get_color("d_green")
local clr_y  = utils_xml.get_color("yellow")

local clr_2  = utils_xml.get_color("ui_gray_1")
original_build_desc_header = ui_item.build_desc_header
function ui_item.build_desc_header(obj, sec, str)
	local _str = ""
	local _str2 = original_build_desc_header(obj, sec, str)
	
    -- display power + psu
	if obj and is_exo(obj) then
        local data = get_data(obj:id())
        if not data then data = init_data(obj:id()) end

        local display_str = ""
        local power = string.format("%.2f", data.power)
        local max_power = data.supply and data.supply.max or 100
        local clr = utils_xml.get_color_con((data.power/max_power) * 100)
        display_str =  display_str .."  " .. clr_y .. gc("st_dot") .. " " .. clr_2 ..  gc("st_power") .. " ".. clr .. data.power .. "/" .. max_power .. "\\n"
        local psu = gc("st_equipped_none")
        clr = clr_r
        if data.supply then
            psu = ui_item.get_sec_name(data.supply.name)
            clr = clr_g
        end
        
        display_str = display_str .. "  " .. clr_y .. gc("st_dot") .. " "  .. clr_2 .. gc("st_equipped_supply") .. " " .. clr .. psu .. clr_2 .. "\\n \\n"
        _str = _str .. display_str
    end
	_str = _str2 .. _str

	return _str
end

local function se_device_on_unregister(se_obj, typ)
    local id = se_obj.id
    exo_devices[id] = nil
end

local function save_state(mdata) 
	mdata.exo_devices = exo_devices
end

local function load_state(mdata) 
	exo_devices = mdata.exo_devices or {}
end

function on_game_start()
    RegisterScriptCallback("save_state",save_state)
    RegisterScriptCallback("load_state",load_state)
    RegisterScriptCallback("ActorMenu_on_item_drag_drop",on_item_drag_dropped)
	RegisterScriptCallback("server_entity_on_unregister",se_device_on_unregister)
	RegisterScriptCallback("actor_on_update",actor_on_update)
	RegisterScriptCallback("actor_item_to_slot",on_move)
	RegisterScriptCallback("actor_item_to_ruck",on_move)

	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
end